s1_res = step1(counts, meta)
# Step 2: Remove features that are differentially abundant in negative controls
## decontam
s2_res = step2(counts, meta, step2_threshold)
# Step 3: Remove if DA in diff batches for technical replicates
s3_res = step3(counts, technical_replicates)
# Step 4: Remove known 'blocklist' of contaminants
s4_res = step4(counts, blocklist)
# Create dataframe indicating TRUE if contaminant and FALSE if not tagged
res = data.frame('feature' = colnames(counts))
res = data.frame('feature' = colnames(counts),
'step1' = ifelse(colnames(counts) %in% s1_res, TRUE, FALSE),
'step2' = ifelse(colnames(counts) %in% s2_res, TRUE, FALSE),
'step3' = ifelse(colnames(counts) %in% s3_res, TRUE, FALSE),
'step4' = ifelse(colnames(counts) %in% s4_res, TRUE, FALSE))
# return column with summed cases where feature was true
# transpose to same as counts matrix
res2 = res
res2$remove = rowSums(res2[,2:5])
res2 = t(res2)
# remove features above specified threshold from original counts frame
counts_rem = rbind(counts, res2['remove',])
rownames(counts_rem)[nrow(counts_rem)] = 'remove'
final_counts = counts[,counts_rem['remove',]<remove_if]
removed = setdiff(colnames(counts), colnames(final_counts))
# determine filtering loss value
FL = FL(counts, removed)
# Create deliverable
deliv = list('contaminant_id' = res,
'decontaminated_count' = final_counts,
'removed' = removed,
'filtering_loss' = FL,
'pipeline' = 'pipeline2')
return(deliv)
}
p2_results = pipeline2(counts, meta, blocklist, technical_replicates)
View(p2_results)
pipeline2 = function(counts, meta, blocklist, technical_replicates, remove_if = 1,
step2_threshold = 0.5, seed = 42) {
set.seed(seed)
# Step 0: W2W check
#  w2w = well2well(counts, meta, seed = seed)
# Step 1: Remove features that showed different abundance in different batches
## ancombc comparison across batches
s1_res = step1(counts, meta)
# Step 2: Remove features that are differentially abundant in negative controls
## decontam
s2_res = step2(counts, meta, step2_threshold)
# Step 3: Remove if DA in diff batches for technical replicates
# s3_res = step3(counts, technical_replicates)
# Step 4: Remove known 'blocklist' of contaminants
s4_res = step4(counts, blocklist)
# Create dataframe indicating TRUE if contaminant and FALSE if not tagged
res = data.frame('feature' = colnames(counts))
res = data.frame('feature' = colnames(counts),
'step1' = ifelse(colnames(counts) %in% s1_res, TRUE, FALSE),
'step2' = ifelse(colnames(counts) %in% s2_res, TRUE, FALSE),
#   'step3' = ifelse(colnames(counts) %in% s3_res, TRUE, FALSE),
'step4' = ifelse(colnames(counts) %in% s4_res, TRUE, FALSE))
# return column with summed cases where feature was true
# transpose to same as counts matrix
res2 = res
res2$remove = rowSums(res2[,2:5])
res2 = t(res2)
# remove features above specified threshold from original counts frame
counts_rem = rbind(counts, res2['remove',])
rownames(counts_rem)[nrow(counts_rem)] = 'remove'
final_counts = counts[,counts_rem['remove',]<remove_if]
removed = setdiff(colnames(counts), colnames(final_counts))
# determine filtering loss value
FL = FL(counts, removed)
# Create deliverable
deliv = list('contaminant_id' = res,
'decontaminated_count' = final_counts,
'removed' = removed,
'filtering_loss' = FL,
'pipeline' = 'pipeline2')
return(deliv)
}
pipeline2 = function(counts, meta, blocklist, technical_replicates, remove_if = 1,
step2_threshold = 0.5, seed = 42) {
set.seed(seed)
# Step 0: W2W check
#  w2w = well2well(counts, meta, seed = seed)
# Step 1: Remove features that showed different abundance in different batches
## ancombc comparison across batches
s1_res = step1(counts, meta)
# Step 2: Remove features that are differentially abundant in negative controls
## decontam
s2_res = step2(counts, meta, step2_threshold)
# Step 3: Remove if DA in diff batches for technical replicates
# s3_res = step3(counts, technical_replicates)
# Step 4: Remove known 'blocklist' of contaminants
s4_res = step4(counts, blocklist)
# Create dataframe indicating TRUE if contaminant and FALSE if not tagged
res = data.frame('feature' = colnames(counts))
res = data.frame('feature' = colnames(counts),
'step1' = ifelse(colnames(counts) %in% s1_res, TRUE, FALSE),
'step2' = ifelse(colnames(counts) %in% s2_res, TRUE, FALSE),
#   'step3' = ifelse(colnames(counts) %in% s3_res, TRUE, FALSE),
'step4' = ifelse(colnames(counts) %in% s4_res, TRUE, FALSE))
# return column with summed cases where feature was true
# transpose to same as counts matrix
res2 = res
res2$remove = rowSums(res2[,-c(1)])
res2 = t(res2)
# remove features above specified threshold from original counts frame
counts_rem = rbind(counts, res2['remove',])
rownames(counts_rem)[nrow(counts_rem)] = 'remove'
final_counts = counts[,counts_rem['remove',]<remove_if]
removed = setdiff(colnames(counts), colnames(final_counts))
# determine filtering loss value
FL = FL(counts, removed)
# Create deliverable
deliv = list('contaminant_id' = res,
'decontaminated_count' = final_counts,
'removed' = removed,
'filtering_loss' = FL,
'pipeline' = 'pipeline2')
return(deliv)
}
p2_results = pipeline2(counts, meta, blocklist, technical_replicates)
View(p2_results)
allTaxa[(allTaxa %in% blocklist)]
d.genus = cbind(batch, group, age, race, group, gen) # remove non MB, move groups to front
blocklist = read.csv("contaminant-blocklist.csv", header = F)
gen = read.csv("Level6_Genus.csv", header=T,row.name=1)
# Extract meta data
batch = gen$Batch
group = gen$Groups
age = gen$Age
race = gen$Race
gen = gen[,1:(ncol(gen)-5)] # remove non-count cols
index = grep(".*.g__*", colnames(gen)) # keep if have IDed genus
gen = gen[,index]
comp = data.frame(colnames(gen))
comp$compare = sub(".*.g__", "", colnames(gen)) # subset to only genus
index2 = which(comp$compare=="")
comp = comp[-index2,]
# Adjust names to genus alone
index = grep(".*.g__*", colnames(gen)) # keep if have IDed genus
gen = gen[,index]
colnames(gen) = sub(".*.g__", "", colnames(gen)) # subset to only genus
index2 = which(names(gen)=="")
gen = gen[,-index2] # remove if no value
## removes 650 based on lack of genus alone
# Create genus phyloseq object with all meta data
d.genus = cbind(batch, group, age, race, group, gen) # remove non MB, move groups to front
colnames(d.genus)[1] = "Batch"
d.genus$Batch[d.genus$Batch=="Old"] = "1. Old" # to set old as reference
d.genus$Batch[d.genus$Batch=="New"] = "2. New"
table(d.genus$Batch)
colnames(d.genus)[2] = "Groups"
d.genus$Groups[d.genus$Groups=="Negative Control"] = "0.Negative Control"
d.genus$Groups[d.genus$Groups=="Control"] = "1.Control"
d.genus$Groups[d.genus$Groups=="Benign"] = "2.Sample"
d.genus$Groups[d.genus$Groups=="Non_EOC"] = "2.Sample"
d.genus$Groups[d.genus$Groups=="EOC"] = "2.Sample"
table(d.genus$Groups)
colnames(d.genus)[3] = "Age"
table(d.genus$Age)
colnames(d.genus)[4] = "Race"
table(d.genus$Race)
colnames(d.genus)[5] = "Ex_Groups"
d.genus$Groups[d.genus$Groups=="Negative Control"] = "0.Negative Control"
d.genus$Groups[d.genus$Groups=="Control"] = "1.Control"
d.genus$Groups[d.genus$Groups=="Benign"] = "2.Sample"
d.genus$Groups[d.genus$Groups=="Non_EOC"] = "3.Sample"
d.genus$Groups[d.genus$Groups=="EOC"] = "4.Sample"
table(d.genus$Groups)
d.genus.ancomBC = t(d.genus[,6:ncol(d.genus)]) # non meta data
d.genus.ancomBC = round(d.genus.ancomBC)
all(colnames(d.genus.ancomBC)==rownames(d.genus))
otu_mat = d.genus.ancomBC
meta = data.frame(group=d.genus$Groups,
batch=d.genus$Batch,
# age=d.genus$Age,
# race=d.genus$Race,
ex_groups=d.genus$Ex_Groups,
row.names=colnames(d.genus.ancomBC))
tax_mat = matrix(rownames(otu_mat),nrow=nrow(otu_mat),ncol=1)
rownames(tax_mat) = rownames(otu_mat)
colnames(tax_mat) = c("genus")
OTU_g = otu_table(otu_mat, taxa_are_rows = TRUE)
META_g = sample_data(meta)
TAX_g = tax_table(tax_mat)
genus = phyloseq(OTU_g, META_g, TAX_g)
# run ANCOMBC
# https://bioconductor.org/packages/release/bioc/vignettes/ANCOMBC/inst/doc/ANCOMBC2.html
genus_s1_res = ancombc(phyloseq = genus, assay_name = "counts",
group = "batch", p_adj_method = "BH",  lib_cut = 0,
formula = "batch",
struc_zero = TRUE, neg_lb = FALSE,
tol = 1e-5, max_iter = 100, conserve = FALSE,
alpha = 0.05, global = TRUE)
genus_s11_res = do.call(cbind, genus_s1_res$res)
View(genus_s11_res)
phyloseq = wrap_phyloseq(counts, meta)
# run differential analysis
suppressWarnings({
s1 = ancombc(phyloseq = phyloseq, assay_name = "counts",
group = "batch", p_adj_method = "BH", lib_cut = 0,
formula = "batch",
struc_zero = TRUE, neg_lb = FALSE,
tol = 1e-5, max_iter = 100, conserve = FALSE,
alpha = 0.05, global = TRUE)
})
# create results matrix
s1_res = do.call(cbind, s1$res)
View(s1_res)
for (i in 1:7) {}
alpha = c('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H')
vert = data.frame()
i = 1
j = 1
print(alpha[i], j, sep = '')
paste0(alpha[i], j, sep = '')
for (i in 1:7) { # rows
alpha = c('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H')
for (j in 1:12) { # columns
vert[i, j] = paste0(alpha[i], j, sep = '')
}
}
View(vert)
well = data.frame()
well[j,i] = paste0(alpha[i], j, sep = '')
remove(vert)
well = data.frame()
for (i in 1:7) { # rows
alpha = c('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H')
for (j in 1:12) { # columns
well[i,j] = paste0(alpha[i], j, sep = '')
}
}
View(well)
unlist(well)
# string for well assignments
vert = c(unlist(well))
vert
# string for well assignments
vert = unname(unlist(well))
vert
horiz = unname(unlist(t(well)))
hori
horiz
t(well)
unlist(t(well))
class(well)
class(t(well))
horiz = unname(unlist(data.frame(t(well))))
horiz
vert
View(meta)
as.numeric(rownames(meta))
sub(".*[^0-9](\\d+)$", "\\1", rownames(meta)[1])
sub(".*[^0-9](\\d+)$", "\\1", rownames(meta)[4])
[order(as.numeric(sub(".*[^0-9](\\d+)$", "\\1", rownames(meta))]
meta[order(as.numeric(sub(".*[^0-9](\\d+)$", "\\1", rownames(meta))]
# append potential horizontal and vertical well orders together
# order batches based on naming convention (number in the end of the string)
meta[order(as.numeric(sub(".*[^0-9](\\d+)$", "\\1", rownames(meta)))]
# append potential horizontal and vertical well orders together
# order batches based on naming convention (number in the end of the string)
meta[order(as.numeric(sub(".*[^0-9](\\d+)$", "\\1", rownames(meta))))]
View(counts)
# append potential horizontal and vertical well orders together
# order batches based on naming convention (number in the end of the string)
meta[order(as.numeric(sub(".*[^0-9](\\d+)$", "\\1", rownames(meta)))),]
meta = meta %>%
mutate(meta[order(as.numeric(sub(".*[^0-9](\\d+)$", "\\1", rownames(meta)))),])
View(meta)
index = grep(".*.g__*", colnames(dat)) # keep if have IDed datus
dat = dat[,index]
comp = data.frame(colnames(dat))
comp$compare = sub(".*.g__", "", colnames(dat)) # subset to only datus
index2 = which(comp$compare=="")
comp = comp[-index2,]
index = grep(".*.g__*", colnames(dat)) # keep if have IDed datus
dat = dat[,index]
colnames(dat) = sub(".*.g__", "", colnames(dat)) # subset to only datus
index2 = which(names(dat)=="")
dat = dat[,-index2] # remove if no value
## dummy res data for pipeline2
res = read.csv('res_toydata.csv')
### dummy data for FL function
removed = sample(rownames(FL), 100)
dat = read.csv("Level6_Genus.csv", header=T,row.name=1)
batch = dat$Batch
group = dat$Groups
index = grep(".*.g__*", colnames(dat)) # keep if have IDed datus
dat = dat[,index]
comp = data.frame(colnames(dat))
comp$compare = sub(".*.g__", "", colnames(dat)) # subset to only datus
index2 = which(comp$compare=="")
comp = comp[-index2,]
index = grep(".*.g__*", colnames(dat)) # keep if have IDed datus
dat = dat[,index]
colnames(dat) = sub(".*.g__", "", colnames(dat)) # subset to only datus
index2 = which(names(dat)=="")
dat = dat[,-index2] # remove if no value
## dummy res data for pipeline2
res = read.csv('res_toydata.csv')
### dummy data for FL function
removed = sample(rownames(FL), 100)
### dummy data for development
dat = read.csv("Level6_Genus.csv", header=T,row.name=1)
batch = dat$Batch
group = dat$Groups
### dummy meta data
control = group
control = control == "Negative Control"
sample = group
sample[!sample == "Control"] = "Plasma"
dat = as.matrix(dat)
meta = data.frame("is_control" = control,
"sample" = sample,
"batch" = batch)
rownames(meta) = rownames(dat)
View(meta)
meta = meta %>%
mutate(meta[order(as.numeric(sub(".*[^0-9](\\d+)$", "\\1", rownames(meta)))),])
dat = read.csv("Level6_Genus.csv", header=T,row.name=1)
batch = dat$Batch
group = dat$Groups
### dummy meta data
control = group
control = control == "Negative Control"
sample = group
sample[!sample == "Control"] = "Plasma"
dat = as.matrix(dat)
meta = data.frame("is_control" = control,
"sample" = sample,
"batch" = batch)
rownames(meta) = rownames(dat)
dat = read.csv("Level6_Genus.csv", header=T,row.name=1)
batch = dat$Batch
group = dat$Groups
### dummy meta data
control = group
control = control == "Negative Control"
sample = group
sample[!sample == "Control"] = "Plasma"
dat = as.matrix(dat)
meta = data.frame("is_control" = control,
"sample" = sample,
"batch" = batch)
rownames(meta) = rownames(dat)
index = grep(".*.g__*", colnames(dat)) # keep if have IDed datus
dat = dat[,index]
comp = data.frame(colnames(dat))
comp$compare = sub(".*.g__", "", colnames(dat)) # subset to only datus
index2 = which(comp$compare=="")
comp = comp[-index2,]
index = grep(".*.g__*", colnames(dat)) # keep if have IDed datus
dat = dat[,index]
colnames(dat) = sub(".*.g__", "", colnames(dat)) # subset to only datus
index2 = which(names(dat)=="")
dat = dat[,-index2] # remove if no value
pipeline2 = function(counts, meta, blocklist, technical_replicates, remove_if = 1,
step2_threshold = 0.5, seed = 42) {
set.seed(seed)
# Step 0: W2W check
#  w2w = well2well(counts, meta, seed = seed)
# Step 1: Remove features that showed different abundance in different batches
## ancombc comparison across batches
s1_res = step1(counts, meta)
# Step 2: Remove features that are differentially abundant in negative controls
## decontam
s2_res = step2(counts, meta, step2_threshold)
# Step 3: Remove if DA in diff batches for technical replicates
s3_res = step3(counts, technical_replicates)
# Step 4: Remove known 'blocklist' of contaminants
s4_res = step4(counts, blocklist)
# Create dataframe indicating TRUE if contaminant and FALSE if not tagged
res = data.frame('feature' = colnames(counts))
res = data.frame('feature' = colnames(counts),
'step1' = ifelse(colnames(counts) %in% s1_res, TRUE, FALSE),
'step2' = ifelse(colnames(counts) %in% s2_res, TRUE, FALSE),
#   'step3' = ifelse(colnames(counts) %in% s3_res, TRUE, FALSE),
'step4' = ifelse(colnames(counts) %in% s4_res, TRUE, FALSE))
# return column with summed cases where feature was true
# transpose to same as counts matrix
res2 = res
res2$remove = rowSums(res2[,-c(1)])
res2 = t(res2)
# remove features above specified threshold from original counts frame
counts_rem = rbind(counts, res2['remove',])
rownames(counts_rem)[nrow(counts_rem)] = 'remove'
final_counts = counts[,counts_rem['remove',]<remove_if]
removed = setdiff(colnames(counts), colnames(final_counts))
# determine filtering loss value
FL = FL(counts, removed)
# Create deliverable
deliv = list('contaminant_id' = res,
'decontaminated_count' = final_counts,
'removed' = removed,
'filtering_loss' = FL,
'pipeline' = 'pipeline2')
return(deliv)
}
View(meta)
### dummy data for development
dat = read.csv("Level6_Genus.csv", header=T,row.name=1)
batch = dat$Batch
group = dat$Groups
View(dat[,c('Batch','Group')])
### dummy meta data
control = group
control = control == "Negative Control"
sample = group
sample[!sample == "Control"] = "Plasma"
meta = data.frame("is_control" = control,
"sample" = sample,
"batch" = batch)
rownames(meta) = rownames(dat)
View(meta)
temp = dat[,]
temp = dat[,c('Batch', 'Groups')]
View(temp)
temp$Control = temp$Groups == "Negative Control"
### dummy data for development
dat = read.csv("Level6_Genus.csv", header=T,row.name=1)
batch = dat$Batch
group = dat$Groups
### dummy meta data
control = group
control = control == "Negative Control"
sample = group
sample[!sample == "Negative Control"] = "Plasma"
meta = data.frame("is_control" = control,
"sample" = sample,
"batch" = batch)
rownames(meta) = rownames(dat)
pipeline2 = function(counts, meta, blocklist, technical_replicates, remove_if = 1,
step2_threshold = 0.5, seed = 42) {
set.seed(seed)
# Step 0: W2W check
#  w2w = well2well(counts, meta, seed = seed)
# Step 1: Remove features that showed different abundance in different batches
## ancombc comparison across batches
s1_res = step1(counts, meta)
# Step 2: Remove features that are differentially abundant in negative controls
## decontam
s2_res = step2(counts, meta, step2_threshold)
# Step 3: Remove if DA in diff batches for technical replicates
s3_res = step3(counts, technical_replicates)
# Step 4: Remove known 'blocklist' of contaminants
s4_res = step4(counts, blocklist)
# Create dataframe indicating TRUE if contaminant and FALSE if not tagged
res = data.frame('feature' = colnames(counts))
res = data.frame('feature' = colnames(counts),
'step1' = ifelse(colnames(counts) %in% s1_res, TRUE, FALSE),
'step2' = ifelse(colnames(counts) %in% s2_res, TRUE, FALSE),
#   'step3' = ifelse(colnames(counts) %in% s3_res, TRUE, FALSE),
'step4' = ifelse(colnames(counts) %in% s4_res, TRUE, FALSE))
# return column with summed cases where feature was true
# transpose to same as counts matrix
res2 = res
res2$remove = rowSums(res2[,-c(1)])
res2 = t(res2)
# remove features above specified threshold from original counts frame
counts_rem = rbind(counts, res2['remove',])
rownames(counts_rem)[nrow(counts_rem)] = 'remove'
final_counts = counts[,counts_rem['remove',]<remove_if]
removed = setdiff(colnames(counts), colnames(final_counts))
# determine filtering loss value
FL = FL(counts, removed)
# Create deliverable
deliv = list('contaminant_id' = res,
'decontaminated_count' = final_counts,
'removed' = removed,
'filtering_loss' = FL,
'pipeline' = 'pipeline2')
return(deliv)
}
pipeline2(counts, meta, blocklist, technical_replicates)
blocklist = c(blocklist[,1])
pipeline2(counts, meta, blocklist, technical_replicates)
p2_results = pipeline2(counts, meta, blocklist, technical_replicates)
View(p2_results)
meta = meta %>%
mutate(meta[order(as.numeric(sub(".*[^0-9](\\d+)$", "\\1", rownames(meta)))),]) %>%
arrange(meta, batch)
### dummy data for development
dat = read.csv("Level6_Genus.csv", header=T,row.name=1)
batch = dat$Batch
group = dat$Groups
### dummy meta data
control = group
control = control == "Negative Control"
sample = group
sample[!sample == "Negative Control"] = "Plasma"
meta = data.frame("is_control" = control,
"sample" = sample,
"batch" = batch)
rownames(meta) = rownames(dat)
meta = meta %>%
mutate(meta[order(as.numeric(sub(".*[^0-9](\\d+)$", "\\1", rownames(meta)))),, drop = FALSE]) %>%
arrange(meta, batch)
### dummy data for development
dat = read.csv("Level6_Genus.csv", header=T,row.name=1)
batch = dat$Batch
group = dat$Groups
### dummy meta data
control = group
control = control == "Negative Control"
sample = group
sample[!sample == "Negative Control"] = "Plasma"
meta = data.frame("is_control" = control,
"sample" = sample,
"batch" = batch)
rownames(meta) = rownames(dat)
