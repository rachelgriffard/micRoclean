# Kruskal-Wallis
k_FVC = kruskal.test(preFVC_Quanpct_pred ~ severity2, dat)
k_FVC
dunn_test(dat, preFVC_Quanpct_pred ~ severity2) %>% kable()
# Kruskal-Wallis
k_IGE = kruskal.test(`IgE (kU/L)` ~ severity2, dat)
k_IGE
dunn_test(dat, `IgE (kU/L)` ~ severity2) %>% kable()
# Kruskal-Wallis
k_bEOS = kruskal.test(as.integer(`Blood_EOS %`) ~ severity2, dat)
k_bEOS
dunn_test(dat, `Blood_EOS %` ~ severity2) %>% kable()
dunn_test(dat, as.integer(`Blood_EOS %`) ~ severity2) %>% kable()
dat$`Blood_EOS %` = as.integer(dat$`Blood_EOS %`)
dunn_test(dat, `Blood_EOS %` ~ severity2) %>% kable()
# Kruskal-Wallis
k_sEOS = kruskal.test(as.integer(`sputum_EOS %`) ~ severity2, dat)
k_sEOS
dat$`sputum_EOS %` = as.integer(`sputum_EOS %`)
dat$`sputum_EOS %` = as.integer(dat$`sputum_EOS %`)
dunn_test(dat, `IgE (kU/L)` ~ severity2) %>% kable()
dunn_test(dat, `sputum_EOS %` ~ severity2) %>% kable()
# ANOVA
# Kruskal-Wallis
k_FENO = kruskal.test(as.integer(`FeNO (ppb)`) ~ severity2, dat)
k_FENO
# Kruskal-Wallis
k_FENOlog = kruskal.test(as.integer(feno_log) ~ severity2, dat)
k_FENOlog
# Kruskal-Wallis
k_exac = kruskal.test(as.integer(`WG_derived_num_exacacerbations (12 mo.)`) ~ severity2, dat)
k_exac
# Kruskal-Wallis
k_act = kruskal.test(as.integer(act_score) ~ severity2, dat)
k_act
# Kruskal-Wallis
k_NC = kruskal.test(as.integer(num_controllers) ~ severity2, dat)
k_NC
dat$num_controllers = as.integer(dat$num_controllers)
dunn_test(dat, num_controllers ~ severity2) %>% kable()
# summary
dat %>%
group_by(severity2) %>%
summarize(n = n(),
mean_bEOS = signif(mean(as.integer(`Blood_EOS %`, na.rm = TRUE)),3),
sd_bEOS = signif(sd(as.integer(`Blood_EOS %`, na.rm = TRUE)),3),
med_bEOS = signif(median(as.integer(`Blood_EOS %`, na.rm = TRUE)),3),
min_bEOS = signif(min(as.integer(`Blood_EOS %`, na.rm = TRUE)),3),
max_bEOS = signif(max(as.integer(`Blood_EOS %`, na.rm = TRUE)),3)) %>%
kable()
# boxplot
p=ggplot(dat, aes(severity2, as.integer(`Blood_EOS %`))) +
geom_boxplot() +
ggtitle('Blood Eos %') +
xlab('Severity') + ylab('Blood EoS%') +
theme_bw()
ggplotly(p)
ggsave('240607_Sundar_miRNA_files/figure-html/bEOS_boxplot.png', p, width = 8, height = 6, dpi = 'print')
# summary
dat %>%
group_by(severity2) %>%
summarize(n = n(),
mean_sEOS = signif(mean(`Blood_EOS %`),3),
sd_sEOS = signif(sd(`Blood_EOS %`),3),
med_sEOS = signif(median(`Blood_EOS %`),3),
min_sEOS = signif(min(`Blood_EOS %`),3),
max_sEOS = signif(max(`Blood_EOS %`),3)) %>%
kable()
dat %>%
group_by(severity2)
View(dat)
# summary
dat %>%
group_by(severity2) %>%
summarize(n = n(),
mean_sEOS = signif(mean(`Blood_EOS %`, na.rm = TRUE),3),
sd_sEOS = signif(sd(`Blood_EOS %`),3),
med_sEOS = signif(median(`Blood_EOS %`),3),
min_sEOS = signif(min(`Blood_EOS %`),3),
max_sEOS = signif(max(`Blood_EOS %`),3)) %>%
kable()
# summary
dat %>%
group_by(severity2) %>%
summarize(n = n(),
mean_sEOS = signif(mean(`Blood_EOS %`, na.rm = TRUE),3),
sd_sEOS = signif(sd(`Blood_EOS %`, na.rm = TRUE),3),
med_sEOS = signif(median(`Blood_EOS %`, na.rm = TRUE),3),
min_sEOS = signif(min(`Blood_EOS %`, na.rm = TRUE),3),
max_sEOS = signif(max(`Blood_EOS %`, na.rm = TRUE),3)) %>%
kable()
dat$`Blood_EOS %` = as.integer(dat$`Blood_EOS %`)
# summary
dat %>%
group_by(severity2) %>%
summarize(n = n(),
mean_bEOS = signif(mean(`Blood_EOS %`, na.rm = TRUE),3),
sd_bEOS = signif(sd(`Blood_EOS %`, na.rm = TRUE),3),
med_bEOS = signif(median(`Blood_EOS %`, na.rm = TRUE),3),
min_bEOS = signif(min(`Blood_EOS %`, na.rm = TRUE),3),
max_bEOS = signif(max(`Blood_EOS %`, na.rm = TRUE),3)) %>%
kable()
dunn_test(dat, `Blood_EOS %` ~ severity2) %>% kable()
dunn_test(dat, `Blood_EOS %` ~ severity2)[,2:7] %>% kable()
max(dat$`Blood_EOS %`, na.rm = TRUE)
fisher.test(dat$severity2, dat$ICS)
set.seed(seed)
setwd("~/GitHub/micRoclean_development")
dat = read.csv("Level6_Genus.csv", header=T,row.name=1)
batch = dat$Batch
group = dat$Groups
index = grep(".*.g__*", colnames(dat)) # keep if have IDed datus
dat = dat[,index]
comp = data.frame(colnames(dat))
comp$compare = sub(".*.g__", "", colnames(dat)) # subset to only datus
index2 = which(comp$compare=="")
comp = comp[-index2,]
index = grep(".*.g__*", colnames(dat)) # keep if have IDed datus
dat = dat[,index]
colnames(dat) = sub(".*.g__", "", colnames(dat)) # subset to only datus
index2 = which(names(dat)=="")
dat = dat[,-index2] # remove if no value
control = group
control = control == "Negative Control"
sample = group
sample[!sample == "Negative Control"] = "Plasma"
sample[sample == "Negative Control"] = "Control"
dat = as.matrix(dat)
meta = data.frame("is_control" = control,
"sample_type" = sample,
"batch" = batch)
rownames(meta) = rownames(dat)
### dummy technical replicates (p2s3)
technical_replicates = data.frame("Batch1" = c("Old_trimmed_2", "Old_trimmed_86",
"Old_trimmed_85", "Old_trimmed_49",
"Old_trimmed_38", "Old_trimmed_3",
"Old_trimmed_13", "Old_trimmed_26"),
"Batch2" = c("New_trimmed_29", "New_trimmed_35",
"New_trimmed_41", "New_trimmed_47",
"New_trimmed_53", "New_trimmed_59",
"New_trimmed_65", "New_trimmed_71"))
seed = 42
counts = dat
set.seed(seed)
# SCRuB
sc_outs = list()
for(b in unique(meta$batch)) {
index = meta %>% filter(batch == b) %>% row.names() # select only of one batch
sc_outs[[b]] = SCRuB(counts[index,],
meta[index,] %>%
select('is_control', 'sample_type', 'sample_well'))
}
library(tidyverse)
for(b in unique(meta$batch)) {
index = meta %>% filter(batch == b) %>% row.names() # select only of one batch
sc_outs[[b]] = SCRuB(counts[index,],
meta[index,] %>%
select('is_control', 'sample_type', 'sample_well'))
}
for(b in unique(meta$batch)) {
index = meta %>% filter(batch == b) %>% row.names() # select only of one batch
sc_outs[[b]] = SCRuB::SCRuB(counts[index,],
meta[index,] %>%
select('is_control', 'sample_type', 'sample_well'))
}
sc_outs[[b]] = SCRuB::SCRuB(counts[index,],
meta[index,] %>%
select(any_of('is_control', 'sample_type', 'sample_well')))
sc_outs[[b]] = SCRuB::SCRuB(counts[index,],
meta[index,] %>%
select(any_of(c('is_control', 'sample_type', 'sample_well'))))
View(sc_outs)
batch = unique(meta$batch)
sc_outs[[batch[1]]]
sc_outs[[batch[1]]][1]
View(sc_outs[[batch[1]]][1])
View(data.frame(sc_outs[[batch[1]]][1]))
View(matrix(sc_outs[[batch[1]]][1]))
View(unlist(sc_outs[[batch[1]]][1]))
View(data.frame(sc_outs[[batch[1]]]$decontaminated_samples))
for (b in batch) {
sc_counts = rbind(sc_outs[[batch[batch]]]$decontaminated_samples)
}
for (b in batch) {
sc_counts = rbind(sc_outs[[batch[b]]]$decontaminated_samples)
}
View(sc_outs)
sc_counts = data.frame()
for (b in batch) {
sc_counts = rbind(sc_outs[[batch[b]]]$decontaminated_samples)
}
sc_counts = rbind(sc_outs[[batch[b]]]$decontaminated_samples)
sc_counts = data.frame()
for (b in batch) {
sc_counts = rbind(sc_counts, sc_outs[[batch[b]]]$decontaminated_samples)
}
View(sc_counts)
sc_counts = data.frame()
b = 'New'
sc_counts = rbind(sc_counts, sc_outs[[batch[b]]]$decontaminated_samples)
View(sc_counts)
# SCRuB
sc_outs = list()
for(b in batch) {
index = meta %>% filter(batch == b) %>% row.names() # select only of one batch
sc_outs[[b]] = SCRuB::SCRuB(counts[index,],
meta[index,] %>%
select(any_of(c('is_control', 'sample_type', 'sample_well'))))$decontaminated_samples
}
View(sc_outs)
sc_counts = unlist(sc_outs)
sc_counts = do.call(sc_outs, rbind)
sc_outs = list(counts, counts)
View(sc_outs)
sc_counts = do.call(sc_outs, rbind)
sc_counts = do.call(rbind, sc_outs)
View(sc_counts)
sc_outs[[b]] = SCRuB::SCRuB(counts[index,],
meta[index,] %>%
select(any_of(c('is_control', 'sample_type', 'sample_well'))))$decontaminated_samples
index = meta %>% filter(batch == b) %>% row.names() # select only of one batch
sum(meta[index, 'is_control']==FALSE) > 0
if (sum(meta[index, 'is_control']==FALSE) > 0) {
stop('To use pipeline1, all batches must contain controls.')
}
sum(meta[index, 'is_control']==FALSE)
sum(meta[index, 'is_control']==TRUE)
# check to ensure each batch contains some controls
for(b in batch) {
index = meta %>% filter(batch == b) %>% row.names() # select within batch
if (sum(meta[index, 'is_control']==TRUE) == 0) {
stop('To use pipeline1, all batches must contain controls.')
}
}
# check to ensure each batch contains some controls
for(b in batch) {
index = meta %>% filter(batch == b) %>% row.names() # select within batch
if (sum(meta[index, 'is_control']==TRUE) == 0) {
stop(paste0('To use pipeline1, all batches must contain controls. Batch',
b, ' does not contain samples specified as controls.', sep = '')) # break loop if missing
}
}
# check to ensure each batch contains some controls
for(b in batch) {
index = meta %>% filter(batch == b) %>% row.names() # select within batch
if (sum(meta[index, 'is_control']==TRUE) == 0) {
stop(paste0('To use pipeline1, all batches must contain controls. Batch ',
b, ' does not contain samples specified as controls.', sep = '')) # break loop if missing
}
}
pipeline1 = function(counts, meta, control_order = NA, seed = 42) {
# check to ensure each batch contains some controls
for(b in batch) {
index = meta %>% filter(batch == b) %>% row.names() # select within batch
if (sum(meta[index, 'is_control']==TRUE) == 0) {
stop(paste0('To use pipeline1, all batches must contain controls. Batch named  ',
b, ' does not contain samples specified as controls.', sep = '')) # break loop if missing
}
}
set.seed(seed)
batch = unique(meta$batch)
# SCRuB
sc_outs = list() # get count matrices from batches scrubbed separately
for(b in batch) {
index = meta %>% filter(batch == b) %>% row.names() # select only of one batch
sc_outs[[b]] = SCRuB::SCRuB(counts[index,],
meta[index,] %>%
select(any_of(c('is_control', 'sample_type', 'sample_well'))))$decontaminated_samples
}
sc_counts = do.call(rbind, sc_outs) # append batches back together
sc_FL = FL(counts, new_counts = sc_counts)
# extract FL values from SCRuB data
# Create deliverable
return(list('decontaminated_count' = sc_counts,
'filtering_loss' = sc_FL,
'pipeline' = 'pipeline1')
)
}
pipeline1(counts, meta)
# basic horiz/vert sort for now
set.seed(seed)
# plate wells
well = data.frame()
for (i in 1:8) { # rows
row = c('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H')
for (j in 1:12) { # columns
well[i,j] = paste0(row[i], j, sep = '')
}
}
# string for well assignments
vert = unname(unlist(well)) # vertical alignment
horiz = unname(unlist(data.frame(t(well)))) # horizontal alignment
# order samples by name convention
meta = meta %>%
arrange(batch, as.numeric(str_extract(rownames(meta), "\\d+$")))
# order batches based on naming convention (number in the end of the string)
meta[order(as.numeric(sub(".*[^0-9](\\d+)$", "\\1", rownames(meta)))),]
# restart at each batch (different plates)
num_b = table(meta$batch)
sample_well = c(vert[1:num_b[1]], vert[1:num_b[2]])
meta_vert = cbind(meta, sample_well)
sample_well = c(horiz[1:num_b[1]], horiz[1:num_b[2]])
meta_horiz = cbind(meta, sample_well)
# order counts by name convention for SCRuB function
counts = as.data.frame(counts) %>%
add_column(meta$batch) %>%
arrange(`meta$batch`, as.numeric(str_extract(rownames(counts), "\\d+$"))) %>%
mutate(`meta$batch` = NULL)
# create SCRuB objects by batch
sc_outs_vert = list()
for(b in unique(meta_vert$batch)) {
index = meta_vert %>% filter(batch == b) %>% row.names()
sc_outs_vert[[b]] = SCRuB(counts[index,],
meta_vert[index,] %>%
select(is_control, sample_type, sample_well))
}
sc_outs_horiz = list()
for(b in unique(meta_horiz$batch)) {
index = meta_horiz %>% filter(batch == b) %>% row.names()
sc_outs_horiz[[b]] = SCRuB(counts[index,],
meta_horiz[index,] %>%
select(is_control, sample_type, sample_well))
}
library(SCRuB)
# create SCRuB objects by batch
sc_outs_vert = list()
for(b in unique(meta_vert$batch)) {
index = meta_vert %>% filter(batch == b) %>% row.names()
sc_outs_vert[[b]] = SCRuB(counts[index,],
meta_vert[index,] %>%
select(is_control, sample_type, sample_well))
}
for(b in unique(meta_horiz$batch)) {
index = meta_horiz %>% filter(batch == b) %>% row.names()
sc_outs_horiz[[b]] = SCRuB(counts[index,],
meta_horiz[index,] %>%
select(is_control, sample_type, sample_well))
}
sc_outs = list()
for(b in unique(meta$batch)) {
index = meta %>% filter(batch == b) %>% row.names()
sc_outs[[b]] = SCRuB(counts[index,],
meta[index,] %>%
select(is_control, sample_type))
}
# append batches back together for full, decontaminated dataframe
SCRuB_vert = do.call(rbind, sc_outs_vert) # append batches back together
SCRuB_horiz = do.call(rbind, sc_outs_horiz) # append batches back together
SCRuB = do.call(rbind, sc_outs) # append batches back together
View(sc_outs_vert)
SCRuB_vert = data.frame(sc_outs_vert[1])
meta_o = meta
meta$is_control
cont = meta$is_control
View(meta)
96*2''
96*2
cont[189:192] = FALSE
cont
meta$is_control = cont
# check to ensure each batch contains some controls
for(b in batch) {
index = meta %>% filter(batch == b) %>% row.names() # select within batch
if (sum(meta[index, 'is_control']==TRUE) == 0) {
stop(paste0('To use pipeline1, all batches must contain controls. Batch named  ',
b, ' does not contain samples specified as controls.', sep = '')) # break loop if missing
}
}
View(meta)
cont[189:192] = TRUE
cont
meta$is_control = cont
# check to ensure each batch contains some controls
for(b in batch) {
index = meta %>% filter(batch == b) %>% row.names() # select within batch
if (sum(meta[index, 'is_control']==TRUE) == 0) {
stop(paste0('To use pipeline1, all batches must contain controls. Batch named  ',
b, ' does not contain samples specified as controls.', sep = '')) # break loop if missing
}
}
set.seed(seed)
batch = unique(meta$batch)
# SCRuB
sc_outs = list() # get count matrices from batches scrubbed separately
for(b in batch) {
index = meta %>% filter(batch == b) %>% row.names() # select only of one batch
sc_outs[[b]] = SCRuB::SCRuB(counts[index,],
meta[index,] %>%
select(any_of(c('is_control', 'sample_type', 'sample_well'))))$decontaminated_samples
}
View(sc_outs)
# order batches based on naming convention (number in the end of the string)
meta[order(as.numeric(sub(".*[^0-9](\\d+)$", "\\1", rownames(meta)))),]
# basic horiz/vert sort for now
set.seed(seed)
# plate wells
well = data.frame()
for (i in 1:8) { # rows
row = c('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H')
for (j in 1:12) { # columns
well[i,j] = paste0(row[i], j, sep = '')
}
}
# string for well assignments
vert = unname(unlist(well)) # vertical alignment
horiz = unname(unlist(data.frame(t(well)))) # horizontal alignment
# order samples by name convention
meta = meta %>%
arrange(batch, as.numeric(str_extract(rownames(meta), "\\d+$")))
# order batches based on naming convention (number in the end of the string)
meta[order(as.numeric(sub(".*[^0-9](\\d+)$", "\\1", rownames(meta)))),]
# restart at each batch (different plates)
num_b = table(meta$batch)
sample_well = c(vert[1:num_b[1]], vert[1:num_b[2]])
meta_vert = cbind(meta, sample_well)
sample_well = c(horiz[1:num_b[1]], horiz[1:num_b[2]])
meta_horiz = cbind(meta, sample_well)
# order counts by name convention for SCRuB function
counts = as.data.frame(counts) %>%
add_column(meta$batch) %>%
arrange(`meta$batch`, as.numeric(str_extract(rownames(counts), "\\d+$"))) %>%
mutate(`meta$batch` = NULL)
# create SCRuB objects by batch
sc_outs_vert = list()
for(b in unique(meta_vert$batch)) {
index = meta_vert %>% filter(batch == b) %>% row.names()
sc_outs_vert[[b]] = SCRuB(counts[index,],
meta_vert[index,] %>%
select(is_control, sample_type, sample_well))
}
View(sc_outs_vert)
meta$sample_type[189:192] = 'Control'
# create SCRuB objects by batch
sc_outs_vert = list()
for(b in unique(meta_vert$batch)) {
index = meta_vert %>% filter(batch == b) %>% row.names()
sc_outs_vert[[b]] = SCRuB(counts[index,],
meta_vert[index,] %>%
select(is_control, sample_type, sample_well))
}
library(vegan)
SCRuB = do.call(rbind, sc_outs) # append batches back together
# append batches back together for full, decontaminated dataframe
SCRuB_vert = do.call(rbind, sc_outs_vert) # append batches back together
View(sc_outs_vert)
View(SCRuB_vert)
SCRuB_vert = sc_outs_vert[[1]]
View(SCRuB_vert)
View(sc_outs)
SCRuB_vert = data.frame(sc_outs_vert[[1]])
View(sc_outs_vert)
# create SCRuB objects by batch
sc_outs_vert = list()
for(b in unique(meta_vert$batch)) {
index = meta_vert %>% filter(batch == b) %>% row.names()
sc_outs_vert[[b]] = SCRuB(counts[index,],
meta_vert[index,] %>%
select(is_control, sample_type, sample_well))$decontaminated_samples
}
# append batches back together for full, decontaminated dataframe
SCRuB_vert = do.call(rbind, sc_outs_vert) # append batches back together
SCRuB_horiz = do.call(rbind, sc_outs_horiz) # append batches back together
SCRuB = do.call(rbind, sc_outs) # append batches back together
# determine if vert/horiz significantly different from without spatial
mantel(vegdist(SCRuB), vegdist(SCRuB_vert)) # maybe, but will have to match columns/zero out if missing
# determine if vert/horiz significantly different from without spatial
mantel(vegdist(SCRuB), vegdist(SCRuB_horiz)) # maybe, but will have to match columns/zero out if missing
SCRuB_horiz = do.call(rbind, sc_outs_horiz) # append batches back together
sc_outs_horiz = list()
for(b in unique(meta_horiz$batch)) {
index = meta_horiz %>% filter(batch == b) %>% row.names()
sc_outs_horiz[[b]] = SCRuB(counts[index,],
meta_horiz[index,] %>%
select(is_control, sample_type, sample_well))$decontaminated_samples
}
View(SCRuB_horiz)
sc_outs_horiz = list()
for(b in unique(meta_horiz$batch)) {
index = meta_horiz %>% filter(batch == b) %>% row.names()
sc_outs_horiz[[b]] = SCRuB(counts[index,],
meta_horiz[index,] %>%
select(is_control, sample_type, sample_well))$decontaminated_samples
}
sc_outs = list()
View(sc_outs_horiz)
SCRuB_horiz = do.call(rbind, sc_outs_horiz) # append batches back together
# determine if vert/horiz significantly different from without spatial
mantel(vegdist(SCRuB), vegdist(SCRuB_horiz)) # maybe, but will have to match columns/zero out if missing
?vegdist
View(SCRuB_horiz)
View(SCRuB_horiz)
View(SCRuB_vert)
View(SCRuB)
View(sc_outs_vert)
sc_outs_vert[[b]] = SCRuB(counts[index,],
meta_vert[index,] %>%
select(is_control, sample_type, sample_well))
View(sc_outs_vert)
b = 'New'
sc_outs_vert[[b]] = SCRuB(counts[index,],
meta_vert[index,] %>%
select(is_control, sample_type, sample_well))
View(sc_outs_vert)
index = meta_vert %>% filter(batch == b) %>% row.names()
sc_outs_vert[[b]] = SCRuB(counts[index,],
meta_vert[index,] %>%
select(is_control, sample_type, sample_well))
View(SCRuB_vert)
View(sc_outs_vert)
sc_outs_vert[[b]] = SCRuB(counts[index,],
meta_vert[index,] %>%
select(is_control, sample_type, sample_well))
